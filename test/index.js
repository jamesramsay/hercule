// Generated by CoffeeScript 1.9.1
(function() {
  var assert, hercule;

  assert = require('assert');

  hercule = require('../lib/transclude');

  describe('hercule', function() {
    describe('scan', function() {
      it('should not detect non-existant placeholders', function(done) {
        var document;
        document = "Test document\nwith no placeholders.";
        hercule.scan(document, "", null, function(err, references) {
          return assert.deepEqual(references, []);
        });
        return done();
      });
      it('should detect placeholders', function(done) {
        var document;
        document = "Test document\nwith {{one}} placeholder.";
        hercule.scan(document, "", null, function(err, references) {
          return assert.equal(references.length, 1);
        });
        return done();
      });
      it('should detect multiple placeholders', function(done) {
        var document;
        document = "Test {{document}}\nwith {{two}} placeholders.";
        hercule.scan(document, "", null, function(err, references) {
          return assert.equal(references.length, 2);
        });
        return done();
      });
      it('should not detect non-existant leading whitespace', function(done) {
        var document;
        document = "word{{test.md}}word";
        hercule.scan(document, "", null, function(err, references) {
          return assert.equal(references[0].whitespace, null);
        });
        return done();
      });
      it('should detect whitespace on the first line of a file', function(done) {
        var document;
        document = "\t{{test}}";
        hercule.scan(document, "", null, function(err, references) {
          return assert.equal(references[0].whitespace, "\t");
        });
        return done();
      });
      it('should detect different types of leading whitespace', function(done) {
        var document, scenario, whitespace, whitespaceScenarios;
        document = "# Heading 1\n";
        whitespaceScenarios = {
          tab: "\t",
          two: " ",
          mixed: "  \t "
        };
        for (scenario in whitespaceScenarios) {
          whitespace = whitespaceScenarios[scenario];
          document += whitespace + "{{" + scenario + "}}\n";
        }
        hercule.scan(document, "", null, function(err, references) {
          var i, len, reference, results;
          results = [];
          for (i = 0, len = references.length; i < len; i++) {
            reference = references[i];
            results.push(assert.equal(reference.whitespace, whitespaceScenarios[reference.placeholder]));
          }
          return results;
        });
        return done();
      });
      return it('should detect alternate link syntax', function(done) {
        var document;
        document = "Test :[document](document)\nwith :[two](two) placeholders.";
        hercule.scan(document, "", null, function(err, references) {
          return assert.equal(references.length, 2);
        });
        return done();
      });
    });
    describe('parse', function() {
      it('should parse a single file reference', function(done) {
        var parsed, testPlaceholder;
        testPlaceholder = "file placeholder:filename.md";
        parsed = hercule.parse(testPlaceholder, null, "", null);
        assert.deepEqual(parsed, {
          file: "file",
          placeholder: testPlaceholder,
          overrides: [
            {
              placeholder: "placeholder",
              type: "file",
              value: "filename.md"
            }
          ]
        });
        return done();
      });
      it('should parse a special reference', function(done) {
        var parsed, testPlaceholder;
        testPlaceholder = "file extend:";
        parsed = hercule.parse(testPlaceholder, null, "", null);
        assert.deepEqual(parsed, {
          file: "file",
          placeholder: testPlaceholder,
          overrides: [
            {
              placeholder: "extend",
              type: "string",
              value: ""
            }
          ]
        });
        return done();
      });
      return it('should parse multiples references', function(done) {
        var dir, parsed, testPlaceholder;
        testPlaceholder = "file fruit:apple.md footer:../common/footer.md copyright:\"Copyright 2014 (c)\"";
        dir = "customer/farmers-market";
        parsed = hercule.parse(testPlaceholder, null, dir, null);
        assert.deepEqual(parsed, {
          file: "customer/farmers-market/file",
          placeholder: testPlaceholder,
          overrides: [
            {
              placeholder: "fruit",
              type: "file",
              value: "customer/farmers-market/apple.md"
            }, {
              placeholder: "footer",
              type: "file",
              value: "customer/common/footer.md"
            }, {
              placeholder: "copyright",
              type: "string",
              value: "Copyright 2014 (c)"
            }
          ]
        });
        return done();
      });
    });
    describe('apply', function() {
      it('should not change the placeholder when there are no overrides', function(done) {
        var placeholder;
        placeholder = hercule.apply("file.md", "file.md", []);
        assert.equal(placeholder, "file.md");
        return done();
      });
      it('should not change the placeholder when there are no matching overrides', function(done) {
        var placeholder;
        placeholder = hercule.apply("file.md", "file.md", [
          {
            placeholder: "footer",
            type: "file",
            value: "footer.md"
          }
        ]);
        assert.equal(placeholder, "file.md");
        return done();
      });
      return it('should change the placeholder when there is a matching override', function(done) {
        var placeholder;
        placeholder = hercule.apply("test.md", "footer", [
          {
            placeholder: "footer",
            type: "file",
            value: "footer.md"
          }
        ]);
        assert.equal(placeholder, "footer.md");
        return done();
      });
    });
    return describe('transclude', function() {
      it('should not change a file without references', function(done) {
        var inputFile;
        inputFile = __dirname + "/fixtures/test-base/fox.md";
        return hercule.transclude(inputFile, null, null, false, function(err, document) {
          if (err) {
            return cb(err);
          }
          assert.equal(document, 'The quick brown fox jumps over the lazy dog.\n');
          return done();
        });
      });
      it('should not change a file without valid references', function(done) {
        var inputFile;
        inputFile = __dirname + "/fixtures/test-invalid/fox.md";
        return hercule.transclude(inputFile, null, null, false, function(err, document) {
          if (err) {
            return cb(err);
          }
          assert.equal(document, 'The quick brown fox {{jumps}} over the lazy dog.\n');
          return done();
        });
      });
      it('should transclude files with valid references', function(done) {
        var inputFile;
        inputFile = __dirname + "/fixtures/test-basic/jackdaw.md";
        return hercule.transclude(inputFile, null, null, false, function(err, document) {
          if (err) {
            return cb(err);
          }
          assert.equal(document, 'Jackdaws love my big sphinx of quartz.\n');
          return done();
        });
      });
      it('should transclude files with valid references with alternate syntax', function(done) {
        var inputFile;
        inputFile = __dirname + "/fixtures/test-link-syntax/jackdaw.md";
        return hercule.transclude(inputFile, null, null, false, function(err, document) {
          if (err) {
            return cb(err);
          }
          assert.equal(document, 'Jackdaws love my big sphinx of quartz.\n');
          return done();
        });
      });
      return it('should transclude files with valid references and overrides', function(done) {
        var inputFile;
        inputFile = __dirname + "/fixtures/test-extend/fox.md";
        return hercule.transclude(inputFile, null, null, false, function(err, document) {
          if (err) {
            return cb(err);
          }
          assert.equal(document, "The quick brown fox jumps over the lazy dog.\n");
          return done();
        });
      });
    });
  });

}).call(this);
