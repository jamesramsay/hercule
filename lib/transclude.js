// Generated by CoffeeScript 1.8.0
(function() {
  var EOL_GROUP, PLACEHOLDER_GROUP, WHITESPACE_GROUP, apply, async, fs, grammar, parse, path, peg, placeholderParser, placeholderRegExp, readFile, scan, transclude, _,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  async = require('async');

  fs = require('fs');

  path = require('path');

  _ = require('lodash');

  peg = require('pegjs');

  grammar = require('./grammar');

  placeholderParser = peg.buildParser(grammar.transcludeGrammar);

  placeholderRegExp = new RegExp(/([\t ]*)?(?:{{|:\[.+?\]\()(.+?)(?:}}|\))/g);

  WHITESPACE_GROUP = 1;

  PLACEHOLDER_GROUP = 2;

  EOL_GROUP = 3;

  parse = function(placeholder, whitespace, dir, verbose) {
    var o, ref, _i, _len, _ref;
    ref = placeholderParser.parse(placeholder);
    ref.file = path.join(dir, ref.file);
    ref.placeholder = placeholder;
    _ref = ref.overrides;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      o = _ref[_i];
      if (o.type === "file") {
        o.value = path.join(dir, o.value);
      }
    }
    if (whitespace != null) {
      ref.whitespace = whitespace;
    }
    if (verbose && ref.overrides.length) {
      console.error("     Parse: " + ref.overrides.length + " overrides found");
    }
    return ref;
  };

  scan = function(document, file, verbose, cb) {
    var dir, match, ref, references;
    dir = path.dirname(file);
    references = [];
    while ((match = placeholderRegExp.exec(document))) {
      ref = parse(match[PLACEHOLDER_GROUP], match[WHITESPACE_GROUP], dir, verbose);
      references.push(ref);
    }
    if (verbose && references.length > 0) {
      console.error("      Scan: " + references.length + " references found");
    }
    return cb(null, references);
  };

  readFile = function(filename, cb) {
    return fs.readFile(filename, function(err, document) {
      if (err) {
        if (err.type = 'ENOENT') {
          console.error("" + filename + " not found.");
          return cb(null, null);
        }
        return cb(err);
      }
      return cb(null, document.toString());
    });
  };

  apply = function(file, placeholder, overrides, verbose) {
    var p, _ref;
    _ref = _.filter(overrides, function(o) {
      return (o != null ? o.placeholder : void 0) === placeholder;
    }), p = _ref[0];
    if (p != null) {
      if (verbose) {
        console.error("  Override: " + placeholder + " >> " + p.value);
      }
      return p.value;
    }
    return file;
  };

  transclude = function(file, parents, placeholderOverrides, verbose, cb) {
    if (parents == null) {
      parents = [];
    }
    if (placeholderOverrides == null) {
      placeholderOverrides = [];
    }
    if (verbose) {
      console.error("Transclude: " + file + " into " + parents.slice(-1)[0]);
    }
    if (__indexOf.call(parents, file) >= 0) {
      return cb("Circular reference detected. " + file + " is in parents:\n" + (JSON.stringify(parents)));
    }
    return readFile(file, function(err, document) {
      if (err) {
        return cb(err);
      }
      return scan(document, file, verbose, function(err, references) {
        if (err) {
          return cb(err);
        }
        if (references.length < 1) {
          return cb(null, document);
        }
        parents.push(file);
        return async.eachSeries(references, function(reference, cb) {
          reference.file = apply(reference.file, reference.placeholder, placeholderOverrides, verbose);
          reference.overrides = _.merge(placeholderOverrides, reference.overrides);
          return transclude(reference.file, parents.slice(0), reference.overrides, verbose, function(err, output) {
            var refRegExp;
            if (err) {
              return cb(err);
            }
            if (output != null) {
              if (reference.whitespace) {
                output = output.replace(/\n/g, "\n" + reference.whitespace);
              }
              output = output.replace(/\n $/, "");
              if (verbose) {
                console.error("    Output:" + (JSON.stringify(output)));
              }
              refRegExp = new RegExp('({{|:\\[.+?\\]\\()' + reference.placeholder + '(}}|\\))', 'g');
              document = document.replace(refRegExp, output);
            }
            return cb(null);
          });
        }, function(err) {
          return cb(null, document);
        });
      });
    });
  };

  module.exports = {
    transclude: transclude,
    scan: scan,
    parse: parse,
    apply: apply
  };

}).call(this);
