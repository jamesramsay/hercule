// Generated by CoffeeScript 1.8.0
(function() {
  var PLACEHOLDER_GROUP, WHITESPACE_GROUP, apply, async, fs, parse, path, placeholderRegExp, readFile, scan, transclude, _,
    __slice = [].slice,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  async = require('async');

  fs = require('fs');

  path = require('path');

  _ = require('lodash');

  placeholderRegExp = new RegExp(/(^[\t ]*)?{{(.+?)}}/gm);

  WHITESPACE_GROUP = 1;

  PLACEHOLDER_GROUP = 2;

  parse = function(overrideStrings, dir, verbose) {
    var filename, o, override, overrides, placeholder, _i, _len, _ref, _ref1;
    if (!overrideStrings) {
      return null;
    }
    overrides = [];
    _ref = (function() {
      var _j, _len, _results;
      _results = [];
      for (_j = 0, _len = overrideStrings.length; _j < _len; _j++) {
        o = overrideStrings[_j];
        _results.push(o.split(":"));
      }
      return _results;
    })();
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      _ref1 = _ref[_i], placeholder = _ref1[0], filename = _ref1[1];
      override = {
        placeholder: placeholder
      };
      if (filename !== '') {
        override.file = path.join(dir, filename);
      }
      overrides.push(override);
    }
    if (verbose && overrides.length > 0) {
      console.error("     Parse: " + overrides.length + " overrides found");
    }
    return overrides;
  };

  scan = function(document, file, verbose, cb) {
    var dir, filename, match, overrides, ref, references, _ref;
    dir = path.dirname(file);
    references = [];
    while ((match = placeholderRegExp.exec(document))) {
      _ref = match[PLACEHOLDER_GROUP].split(" "), filename = _ref[0], overrides = 2 <= _ref.length ? __slice.call(_ref, 1) : [];
      ref = {
        file: path.join(dir, filename),
        placeholder: match[PLACEHOLDER_GROUP],
        overrides: parse(overrides, dir, verbose),
        index: match.index
      };
      if (match[WHITESPACE_GROUP] != null) {
        ref.whitespace = match[WHITESPACE_GROUP];
        if (verbose) {
          console.error("Whitespace: '" + (JSON.stringify(ref.whitespace)) + "' leading whitespace");
        }
      }
      references.push(ref);
    }
    if (verbose && references.length > 0) {
      console.error("      Scan: " + references.length + " references found");
    }
    return cb(null, references);
  };

  readFile = function(filename, cb) {
    return fs.readFile(filename, function(err, document) {
      if (err) {
        if (err.type = 'ENOENT') {
          console.error("" + filename + " not found.");
          return cb(null, null);
        }
        return cb(err);
      }
      return cb(null, document.toString());
    });
  };

  apply = function(file, placeholder, overrides, verbose) {
    var p, _ref;
    _ref = _.filter(overrides, function(o) {
      return (o != null ? o.placeholder : void 0) === placeholder;
    }), p = _ref[0];
    if (p != null) {
      if (verbose) {
        console.error("  Override: " + placeholder + " >> " + p.file);
      }
      return p.file;
    }
    return file;
  };

  transclude = function(file, parents, placeholderOverrides, verbose, cb) {
    if (parents == null) {
      parents = [];
    }
    if (placeholderOverrides == null) {
      placeholderOverrides = [];
    }
    if (verbose) {
      console.error("Transclude: " + file + " into " + parents.slice(-1)[0]);
    }
    if (__indexOf.call(parents, file) >= 0) {
      return cb("Circular reference detected. " + file + " is in parents:\n" + (JSON.stringify(parents)));
    }
    return readFile(file, function(err, document) {
      if (err) {
        return cb(err);
      }
      return scan(document, file, verbose, function(err, references) {
        if (err) {
          return cb(err);
        }
        if (references.length < 1) {
          return cb(null, document);
        }
        parents.push(file);
        return async.eachSeries(references, function(reference, cb) {
          reference.file = apply(reference.file, reference.placeholder, placeholderOverrides, verbose);
          reference.overrides = _.merge(placeholderOverrides, reference.overrides);
          return transclude(reference.file, parents.slice(0), reference.overrides, verbose, function(err, output) {
            var refRegExp;
            if (err) {
              return cb(err);
            }
            if (output != null) {
              if (reference.whitespace) {
                output = output.replace(/\n/g, "\n" + reference.whitespace);
              }
              output = output.replace(/\n$/, "");
              if (verbose) {
                console.error("    Output:" + (JSON.stringify(output)));
              }
              refRegExp = new RegExp("{{" + reference.placeholder + "}}", "g");
              document = document.replace(refRegExp, output);
            }
            return cb(null);
          });
        }, function(err) {
          return cb(null, document);
        });
      });
    });
  };

  module.exports = {
    transclude: transclude,
    scan: scan,
    parse: parse,
    apply: apply
  };

}).call(this);
